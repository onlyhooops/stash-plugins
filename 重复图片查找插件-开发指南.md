# 重复图片查找插件 - 开发指南

**文档版本**: 1.2  
**目标**: 开发一款 Stash 插件，用于查找库中存在的重复图片  
**适用对象**: 插件开发者  
**更新日期**: 2025-02-28  

---

## 1. 概述

### 1.1 插件目标

- **完全重复**：基于文件 MD5 指纹，找出内容完全相同的图片
- **可选扩展**：基于 phash 感知哈希，找出视觉相似的图片（如缩放、压缩后仍相似）

### 1.2 技术可行性

- Stash 在扫描时已为图片文件计算并存储 **MD5** 指纹（`files_fingerprints` 表）
- GraphQL API 可通过 `findImages` 获取图片及其 `visual_files.fingerprints`
- 插件可通过 **任务类**（嵌入式 JS 或外部二进制）调用 GraphQL 完成查找逻辑
- UI 插件可通过 `PluginApi` 实现独立页面、分组预览、勾选删除、导航注入

### 1.3 与 Scene Duplicate Checker 对齐

本插件的**入口与对比页面**需与原生 **Scene Duplicate Checker** 保持一致风格与交互：

- **入口位置**：设置 → Tools → Scene Tools 区域，按钮位于「Scene Duplicate Checker」下方
- **页面风格**：深色主题、Card 布局、Form 筛选区、Table 展示、分页栏
- **交互逻辑**：Search Accuracy 下拉、Select Options、勾选框、单条/批量删除、底部状态栏

### 1.4 能力矩阵

| 能力 | 实现方式 | 说明 |
|------|----------|------|
| 查找重复 | 任务插件 | 在任务页触发，或由 UI 页内部调用 |
| 独立操作页面 | UI 插件 | `register.route('/plugin/duplicate-images', Component)` |
| Tools 入口 | UI 插件 | patch `SettingsToolsSection`，仅在 Scene Tools 区域添加「重复图片查找器」按钮 |
| 分组预览 | UI 插件 | Table 行内缩略图 + HoverPopover、LightboxLink |
| 勾选删除 | UI 插件 | Checkbox + `useImagesDestroy` |
| 插件配置 | YAML settings | 出现在 **设置 → 插件** 对应插件的配置面板 |

### 1.5 输出形态

- **任务输出**：重复组列表（每组包含相同 MD5 的多张图片 ID、路径等）
- **UI 展示**：与 Scene Duplicate Checker 一致的 Table 布局、Details/File Size/Resolution 列、Delete 操作列

---

## 2. 开发环境准备

### 2.1 前置条件

- 已搭建可运行的 Stash 实例（支持插件）
- 了解 Stash 插件配置格式（见 `Stash插件开发规范.md`）
- 熟悉 GraphQL 基本用法

### 2.2 插件目录结构

**仅任务插件**：
```
plugins/
└── duplicate-image-finder/
    ├── duplicate-image-finder.yml
    ├── find-duplicates.js
    └── README.md
```

**任务 + UI 完整版**：
```
plugins/
└── duplicate-image-finder/
    ├── duplicate-image-finder.yml    # 含 ui、tasks、settings
    ├── find-duplicates.js            # 任务入口
    ├── duplicate-finder-ui.js        # UI 入口（路由、patch、页面逻辑）
    ├── duplicate-finder.css          # 可选样式
    └── README.md
```

### 2.3 相关文档与源码

| 文档/路径 | 用途 |
|-----------|------|
| `Stash插件开发规范.md` | 插件配置、任务、Hook、嵌入式/外部插件 |
| `插件开发规范与UI插件可用接口调研报告.md` | UI 插件 API、PluginApi、StashService |
| `pkg/plugin/examples/` | 任务插件示例（gorpc、embedded js） |
| `pkg/plugin/util/client.go` | GraphQL 客户端工具 |
| `graphql/schema/types/image.graphql` | Image、FindImages 等 schema |
| `graphql/schema/types/file.graphql` | ImageFile、fingerprints 等 schema |
| `ui/v2.5/src/components/SceneDuplicateChecker/` | 原生重复检测页面，供 UI 风格与交互对标 |
| `ui/v2.5/src/components/Settings/SettingsToolsPanel.tsx` | Tools 入口布局，patch `SettingsToolsSection` 的参考 |

---

## 3. 数据模型与 API

### 3.1 关键数据结构

```
Image
├── id
├── paths { thumbnail, preview, image }
├── visual_files [VisualFile]
│   └── ImageFile
│       ├── id
│       ├── path
│       └── fingerprints [{ type, value }]
```

- `fingerprints` 中 `type: "md5"` 的 `value` 为文件内容哈希
- 同一 MD5 对应多张图片 → 完全重复

### 3.2 findImages 查询

```graphql
query FindImagesForDuplicateCheck($filter: FindFilterType) {
  findImages(filter: $filter) {
    count
    images {
      id
      title
      paths { thumbnail preview image }
      visual_files {
        ... on ImageFile {
          id
          path
          fingerprints { type value }
        }
      }
    }
  }
}
```

### 3.3 分页参数

`FindFilterType` 常用字段：

- `per_page`: 每页数量（建议 100–500）
- `page`: 页码（从 1 开始）

---

## 4. 核心算法

### 4.1 完全重复检测流程

```
1. 初始化 md5ToImages = {}  // md5 -> [{ imageId, fileId, path, title }]
2. page = 1
3. 循环:
   a. 调用 findImages(filter: { per_page, page })
   b. 对每张 image:
      - 遍历 visual_files
      - 取 type="md5" 的 value
      - 若无 md5，跳过或记录「未计算指纹」列表
      - 将 { imageId, fileId, path, title } 加入 md5ToImages[md5]
   c. 若 page * per_page >= count，退出
   d. page++
4. 遍历 md5ToImages，筛选出 value.length > 1 的组
5. 输出重复组
```

### 4.2 输出格式建议

```json
{
  "output": {
    "duplicate_groups": [
      {
        "md5": "abc123...",
        "count": 3,
        "images": [
          { "id": 1, "path": "/path/to/a.jpg", "title": "A" },
          { "id": 2, "path": "/path/to/b.jpg", "title": "B" },
          { "id": 3, "path": "/path/to/c.jpg", "title": "C" }
        ]
      }
    ],
    "total_images": 1000,
    "images_without_fingerprint": 5,
    "groups_count": 2
  }
}
```

---

## 5. 插件配置

### 5.1 基础配置（嵌入式 JavaScript）

```yaml
name: Duplicate Image Finder
id: duplicate-image-finder
description: 查找 Stash 库中的重复图片（基于 MD5 指纹）
version: "1.0.0"
url: https://github.com/your/repo

exec:
  - find-duplicates.js
interface: js

tasks:
  - name: Find Duplicate Images
    description: 扫描所有图片，按 MD5 分组找出重复项
    defaultArgs: {}
```

### 5.2 外部二进制配置（Go，可选）

```yaml
name: Duplicate Image Finder
id: duplicate-image-finder
description: 查找 Stash 库中的重复图片
version: "1.0.0"

exec:
  - find-duplicates    # 或 {pluginDir}/find-duplicates
interface: rpc
errLog: info

tasks:
  - name: Find Duplicate Images
    description: 扫描所有图片，按 MD5 分组找出重复项
```

### 5.3 任务 + UI 完整配置

```yaml
name: Duplicate Image Finder
id: duplicate-image-finder
description: 查找 Stash 库中的重复图片，支持分组预览与勾选删除
version: "1.0.0"
url: https://github.com/your/repo

# 插件配置（出现在 设置 → 插件 中）
# 格式：settings.<key> 下为 type(NUMBER|STRING|BOOLEAN)、displayName、description
settings:
  defaultPerPage:
    type: NUMBER
    displayName: 每页数量
    description: 分页获取图片时的每页数量（默认 100）

# 任务
exec:
  - find-duplicates.js
interface: js
tasks:
  - name: Find Duplicate Images
    description: 扫描所有图片，按 MD5 分组找出重复项

# UI
ui:
  javascript:
    - duplicate-finder-ui.js
  css:
    - duplicate-finder.css
```

---

## 6. 分步实现指南

### 6.1 第一阶段：嵌入式 JS 最小可行版本

**目标**：能跑通任务，输出任意一条重复信息或「无重复」。

1. **创建插件配置**  
   - 在 `plugins/` 下创建 `duplicate-image-finder.yml`
   - 填写 `name`、`id`、`exec`、`interface`、`tasks`

2. **编写 `find-duplicates.js`**
   - 使用全局 `input` 获取任务输入
   - 使用 `gql.Do(query, variables)` 调用 `findImages`
   - 首次仅请求 1 页、小 `per_page`（如 10），验证能拿到 `images` 和 `visual_files.fingerprints`

3. **实现分页循环**
   - 用 `findImages.count` 计算总页数
   - 循环请求直到获取全部图片

4. **实现 MD5 分组**
   - 遍历所有 image，提取 md5
   - 用对象 `{}` 或 `Map` 按 md5 分组

5. **输出结果**
   - 返回 `{ output: JSON.stringify(result) }` 符合 Plugin task output 格式
   - 用 `log.Info()`、`log.Progress()` 输出进度

6. **在 Stash 中测试**
   - 放入插件目录，Reload Plugins
   - 在任务页执行「Find Duplicate Images」
   - 查看任务输出和 Stash 日志

### 6.2 第二阶段：完善与健壮性

1. **处理无 fingerprint 的图片**
   - 统计并输出 `images_without_fingerprint` 列表
   - 提示用户运行扫描或生成指纹任务

2. **进度反馈**
   - 每处理一页调用 `log.Progress(processedCount / totalCount)`

3. **错误处理**
   - 对 `gql.Do` 失败进行 try/catch，返回 `{ error: "..." }`

4. **可选参数**
   - 在 `defaultArgs` 或任务参数中加入 `per_page`，便于调优

### 6.3 第三阶段：外部二进制（可选）

若需要更高性能或复杂逻辑，可改为 Go 外部插件：

1. 参考 `pkg/plugin/examples/gorpc/main.go`
2. 实现 `common.RPCRunner`，提供 `Run` 方法
3. 使用 `util.NewClient(input.ServerConnection)` 创建 GraphQL 客户端
4. 复用上述分页与分组逻辑

### 6.4 第四阶段：UI 插件（完整版）

#### 6.4.1 注册独立操作页面

```javascript
const DuplicateFinderPage = () => { /* 见 7.2 节 */ };
PluginApi.register.route("/plugin/duplicate-images", DuplicateFinderPage);
```

访问路径：`/plugin/duplicate-images`。需通过导航或设置入口引导用户访问。

#### 6.4.2 注入设置 → Tools → Scene Tools 入口（推荐）

在 **设置 → Tools → Scene Tools** 区域添加「重复图片查找器」按钮，与「Scene Duplicate Checker」并列，样式一致（蓝色 Button）。使用 `patch.before("SettingsToolsSection", ...)`，并**仅**在 Scene Tools 区块追加按钮（通过 `React.Children.count(props.children) >= 2` 判断，因 Scene Tools 含两个 Setting）：

```javascript
PluginApi.patch.before("SettingsToolsSection", function (props) {
  const { Setting } = PluginApi.components;
  const { Link } = PluginApi.libraries.ReactRouterDOM;
  const { Button } = PluginApi.libraries.Bootstrap;
  const React = PluginApi.React;

  // 仅 Scene Tools 区域有 2 个按钮（Parser + Checker），Tools 区域只有 1 个
  const childCount = React.Children.count(props.children);
  if (childCount < 2) return [props];

  return [{
    children: (
      <>
        {props.children}
        <Setting
          heading={
            <Link to="/plugin/duplicate-images">
              <Button>重复图片查找器</Button>
            </Link>
          }
        />
      </>
    )
  }];
});
```

效果：点击后跳转到 `/plugin/duplicate-images`，展示与 Scene Duplicate Checker 风格一致的**全页对比**（与 `/sceneDuplicateChecker` 一样，离开设置侧边栏，进入独立页面）。

#### 6.4.3 重复对比页面 UI 规范（对标 Scene Duplicate Checker）

参考 `ui/v2.5/src/components/SceneDuplicateChecker/SceneDuplicateChecker.tsx`，页面结构应与之一致：

**整体布局**

- 根容器：`<Card id="image-duplicate-checker" className="col col-xl-12 mx-auto">`
- 复用主应用深色主题，无需额外覆盖

**搜索参数区（Form）**

| 控件 | 说明 | 图片版对应 |
|------|------|------------|
| Search Accuracy | 下拉：Exact / High / Medium / Low | **Exact**（仅 MD5 完全匹配）；若支持 phash 相似则对应 distance 0/4/8/10 |
| 说明文案 | "Levels below 'Exact' can take longer..." | 可改为「仅 Exact 基于 MD5，更严格；相似检测需生成 phash」 |
| Maximum Duration Difference | 视频专用 | 图片版可改为 **Maximum File Size Difference** 或省略 |
| Select Options... | 下拉菜单 | 保留：选择全部/选择除最大分辨率外/选择除最大文件外/选最旧/选最新 |
| Checkbox | "Only select if all codecs match..." | 图片版可改为「仅当格式一致时勾选」或省略 |

**状态与警告**

- 橙色警告图标 + 文案：`Missing phashes for X images. Please run the phash generation task.`（或针对 MD5：`Missing fingerprints for X images. Please run a full scan.`）
- 状态文字：`X sets of duplicates found.`

**表格（Table）**

- `responsive striped`，列：`checkbox` | `sprite/thumbnail` | `details` | `file_size` | `resolution` | `delete`
- 行内缩略图：`paths.thumbnail`，`HoverPopover` 展示 `paths.preview` 大图
- Details 列：`Link` 到 `/images/{id}`，下方显示 `path`
- 行间分隔：`<tr className="separator" />`（与 Scene Duplicate Checker 相同）
- 空结果：`<h4 className="text-center mt-4">No duplicates found.</h4>`

**底部**

- 分页、每页条数选择、删除/编辑按钮组（与选中数量联动）

**缩略图与预览**

- 表格内缩略图：`<img src={img.paths?.thumbnail} />`，`HoverPopover` 包裹以悬停放大
- 点击大图：可用 `LightboxLink` 包裹，传入 `images: [{ id, paths }]`

#### 6.4.4 勾选与批量删除

1. **状态**：用 `useState` 维护 `selectedIds: Set<string>`
2. **Checkbox**：Bootstrap `Form.Check` 或原生 `input type="checkbox"`，勾选时更新 `selectedIds`
3. **删除**：使用 `PluginApi.utils.StashService.useImagesDestroy(input)`，input 为 `{ ids: string[], delete_file?: boolean, delete_generated?: boolean }`，返回 `[mutate]`，调用 `await mutate()` 执行。选中变化时可更新 input 并重新渲染，或使用 `GQL.useImagesDestroyMutation` 在调用时传 variables

4. **确认**：删除前弹出确认框（如 `AlertModal` 或 Bootstrap `Modal`），避免误删

#### 6.4.5 数据流设计

**方案 A**：UI 页自行实现查找逻辑  
- 使用 `useFindImages` 分页拉取全部图片，在前端按 MD5 分组，与任务逻辑一致  
- 优点：无需先跑任务，打开页面即能展示  
- 缺点：图片量大时首屏可能较慢，需做好分页与懒加载

**方案 B**：任务 + 缓存  
- 任务执行后将结果写入插件可读路径（如通过 `server_connection`），UI 页读取  
- Stash 插件 API 不直接提供「任务结果文件」机制，需外部插件写文件或通过其他通道传递

**推荐**：方案 A，在 UI 页内复用任务中的 GraphQL 查询与分组算法，用 `useFindImages` 或 `queryFindImages` 分页获取。

#### 6.4.6 读取插件配置

通过 `PluginApi.hooks.useSettings()` 获取 `plugins`，再取 `plugins[pluginID]` 得到当前插件的配置值：

```javascript
const { plugins } = PluginApi.hooks.useSettings();
const perPage = plugins["duplicate-image-finder"]?.defaultPerPage ?? 100;
```

---

## 7. 参考实现

### 7.1 嵌入式 JS 任务骨架

```javascript
(function() {
  var perPage = 100;
  var page = 1;
  var totalCount = 0;
  var md5ToImages = {};
  var noFp = [];

  function getMd5(fingerprints) {
    if (!fingerprints) return null;
    var fp = fingerprints.find(function(f) { return f.type === "md5"; });
    return fp ? fp.value : null;
  }

  function fetchPage() {
    var query = "query($filter: FindFilterType) { findImages(filter: $filter) { count images { id title paths { image } visual_files { ... on ImageFile { id path fingerprints { type value } } } } } }";
    var result = gql.Do(query, { filter: { per_page: perPage, page: page } });
    var data = result.findImages;
    if (!data) return { done: true };
    totalCount = data.count;
    var images = data.images || [];

    for (var i = 0; i < images.length; i++) {
      var img = images[i];
      var files = img.visual_files || [];
      for (var j = 0; j < files.length; j++) {
        var f = files[j];
        var md5 = getMd5(f.fingerprints);
        if (!md5) {
          noFp.push({ id: img.id, path: f.path });
          continue;
        }
        if (!md5ToImages[md5]) md5ToImages[md5] = [];
        md5ToImages[md5].push({
          imageId: img.id,
          fileId: f.id,
          path: f.path,
          title: img.title || ""
        });
      }
    }

    log.Progress((page * perPage) / Math.max(totalCount, 1));
    return { done: images.length < perPage || page * perPage >= totalCount };
  }

  while (true) {
    var r = fetchPage();
    if (r && r.done) break;
    page++;
  }

  var groups = [];
  for (var md5 in md5ToImages) {
    var arr = md5ToImages[md5];
    if (arr.length > 1) {
      groups.push({ md5: md5, count: arr.length, images: arr });
    }
  }

  return {
    output: JSON.stringify({
      duplicate_groups: groups,
      total_images: totalCount,
      images_without_fingerprint: noFp.length,
      groups_count: groups.length
    })
  };
})();
```

### 7.2 UI 页面骨架（对标 Scene Duplicate Checker）

```javascript
(function() {
  const PluginApi = window.PluginApi;
  const React = PluginApi.React;
  const { Link } = PluginApi.libraries.ReactRouterDOM;
  const { Button, Form, Card, Row, Col, Table } = PluginApi.libraries.Bootstrap;

  const DuplicateFinderPage = () => {
    const [groups, setGroups] = React.useState([]);  // [[img, img, ...], ...]
    const [loading, setLoading] = React.useState(true);
    const [checkedIds, setCheckedIds] = React.useState({});
    const { useFindImages } = PluginApi.utils.StashService;
    const { useImagesDestroy } = PluginApi.utils.StashService;
    const { useLoadComponents, useToast } = PluginApi.hooks;
    const { LoadingIndicator, HoverPopover, Setting } = PluginApi.components;

    useLoadComponents([PluginApi.loadableComponents.HoverPopover]);
    const { data } = useFindImages(/* ListFilterModel 或 GQL variables */);
    React.useEffect(() => {
      if (!data?.findImages?.images) return;
      const md5Map = {};
      data.findImages.images.forEach((img) => {
        const fp = img.visual_files?.[0]?.fingerprints?.find((f) => f.type === "md5");
        if (!fp) return;
        if (!md5Map[fp.value]) md5Map[fp.value] = [];
        md5Map[fp.value].push(img);
      });
      setGroups(Object.values(md5Map).filter((arr) => arr.length > 1));
      setLoading(false);
    }, [data]);

    const toggleCheck = (id) => setCheckedIds((prev) => ({ ...prev, [id]: !prev[id] }));
    const [destroyImages] = useImagesDestroy({ ids: Object.keys(checkedIds).filter((k) => checkedIds[k]), delete_file: true });
    const { toast } = useToast();

    if (loading) return <LoadingIndicator />;
    const flatGroups = groups.flat();

    return (
      <Card id="image-duplicate-checker" className="col col-xl-12 mx-auto">
        <div className="duplicate-checker">
          <h4>Duplicate Images</h4>
          <Form>
            <Form.Group>
              <Row noGutters>
                <Form.Label>Search Accuracy</Form.Label>
                <Col xs="auto">
                  <Form.Control as="select" className="input-control ml-4">
                    <option value={0}>Exact</option>
                  </Form.Control>
                </Col>
              </Row>
              <Form.Text>Exact matches by MD5 only.</Form.Text>
            </Form.Group>
          </Form>
          <p>{groups.length} sets of duplicates found.</p>
          <Table responsive striped>
            <thead>
              <tr>
                <th></th>
                <th></th>
                <th>Details</th>
                <th>File Size</th>
                <th>Resolution</th>
                <th>Delete</th>
              </tr>
            </thead>
            <tbody>
              {flatGroups.map((img, idx) => (
                <tr key={img.id}>
                  <td>
                    <Form.Check checked={!!checkedIds[img.id]} onChange={() => toggleCheck(img.id)} />
                  </td>
                  <td>
                    <HoverPopover content={<img src={img.paths?.preview} alt="" width={400} />} placement="right">
                      <img src={img.paths?.thumbnail} alt="" width={100} />
                    </HoverPopover>
                  </td>
                  <td>
                    <Link to={`/images/${img.id}`}>{img.title || img.visual_files?.[0]?.path}</Link>
                  </td>
                  <td>{img.visual_files?.[0]?.size ?? 0}</td>
                  <td>{img.visual_files?.[0] ? `${img.visual_files[0].width}x${img.visual_files[0].height}` : ""}</td>
                  <td>
                    <Button variant="danger" size="sm" onClick={() => destroyImages()}>Delete</Button>
                  </td>
                </tr>
              ))}
            </tbody>
          </Table>
          {groups.length === 0 && <h4 className="text-center mt-4">No duplicates found.</h4>}
        </div>
      </Card>
    );
  };

  PluginApi.register.route("/plugin/duplicate-images", DuplicateFinderPage);

  PluginApi.patch.before("SettingsToolsSection", (props) => {
    const { Setting } = PluginApi.components;
    const { Link } = PluginApi.libraries.ReactRouterDOM;
    const { Button } = PluginApi.libraries.Bootstrap;
    if (PluginApi.React.Children.count(props.children) < 2) return [props];
    return [{
      children: <><>{props.children}</><Setting heading={<Link to="/plugin/duplicate-images"><Button>重复图片查找器</Button></Link>} /></>
    }];
  });
})();
```

> **注意**：
> - `useFindImages` 需传入 `ListFilterModel` 或 `GQL.useFindImagesQuery` 的 variables
> - 完整实现需分页拉取全部图片、支持 Select Options、DeleteScenesDialog 风格的确认弹窗
> - 样式可复用 `#scene-duplicate-checker` 的 `.scene-path`、`.filter-container` 等类；插件 CSS 中可定义 `#image-duplicate-checker` 同名类以保持一致

---

## 8. 测试与验证

### 8.1 测试数据准备

- 准备 2–3 组完全相同的图片（复制同一文件到不同路径）
- 确保这些图片已被 Stash 扫描并生成 MD5

### 8.2 验证点

- [ ] 任务能正常触发且不报错
- [ ] 能正确识别完全相同的图片组
- [ ] 无 MD5 的图片被正确统计/提示
- [ ] 进度显示正常
- [ ] 输出 JSON 结构正确、可解析

### 8.3 日志查看

- Stash 日志中可查看 `log.Info`、`log.Error` 等输出
- 任务 output 会以 debug 级别写入

### 8.4 UI 插件验证

- [ ] 访问 `/plugin/duplicate-images` 能正常打开页面
- [ ] 导航栏或设置页入口可见且能跳转
- [ ] 重复组能正确展示，缩略图加载正常
- [ ] Lightbox 点击预览正常
- [ ] 勾选、取消勾选、批量删除流程正常
- [ ] 设置 → 插件 中能看到本插件及其配置项

---

## 9. 扩展方向

### 9.1 相似图片（phash）

- 确保设置中开启「Generate image phashes during scan」
- 获取每张图片的 `type: "phash"` 指纹（int64）
- 计算汉明距离，将距离小于阈值的归为一组
- 需在插件内实现 phash 距离计算，或调用 Stash 的 `phash_distance` 相关 filter（若 API 支持批量）

### 9.2 导出报告

- 将重复组导出为 CSV/JSON 文件
- 外部插件可写文件到 `server_connection.Dir` 或用户指定路径

### 9.3 批量删除

- **Mutation**：`imagesDestroy(input: ImagesDestroyInput!)`
- **Input**：`{ ids: [ID!]!, delete_file?: Boolean, delete_generated?: Boolean }`
- **用法**：`PluginApi.utils.StashService.useImagesDestroy({ ids, delete_file: true })` 返回 `[mutate]`，`await mutate()` 执行
- **确认**：删除前使用 `AlertModal` 或 Bootstrap `Modal` 二次确认

---

## 10. 常见问题与注意事项

| 问题 | 说明 |
|------|------|
| 部分图片无 MD5 | 需先运行完整扫描；旧库可能未计算 fingerprint，可提示用户重新扫描 |
| patch 不生效 | 组件名必须与 Patchable 列表完全一致（如 `SettingsToolsSection`）；插件需 enabled 且脚本已加载 |
| 按钮出现在 Tools 区 | 用 `React.Children.count(props.children) >= 2` 限制仅在 Scene Tools 区域添加；若 Stash 结构调整，可调整该判断 |
| useLoadComponents | 使用 ImageCard、LightboxLink 等懒加载组件前，需先 `useLoadComponents([...])` 完成加载 |
| LightboxLink 白屏 | 确认 `images` 格式含 `paths`，且 `thumbnail`/`image` URL 有效 |
| 跨域/CSP | 若加载外部资源，需在插件配置的 `ui.csp` 中声明 `script-src`、`connect-src` 等 |

---

## 11. 参考链接

- [Stash 插件文档](https://docs.stashapp.cc/plugins/)
- [CommunityScripts](https://github.com/stashapp/CommunityScripts)
- [Forum - Plugins](https://discourse.stashapp.cc/c/plugins/18)
- 本仓库：`Stash插件开发规范.md`、`插件开发规范与UI插件可用接口调研报告.md`

---

**文档结束。**
